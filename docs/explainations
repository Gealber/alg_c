This document contains an explanation of each algorithm.
In case of any error please contact with me :)

====================================================================
MAX_HEAPIFY:
This is a the heap to be max-heapify:
(A) --- |16|4|10|14|7|9|3|2|8|1|
            ^
(B) --- |16|14|10|4|7|9|3|2|8|1|
                            ^
(C) --- |16|14|10|8|7|9|3|2|4|1|

Which also can be seen in this ugly graphical :?/
representation:
				16
		       /  \
		     4     10
(A)		    / \   /  \
		  14   7 9    3
	      / \ /  
		2   8 1





				16
		       /  \
		     14     10
(B)		    / \    /  \
		  4    7  9    3
	     / \  /   
		2   8 1




				16
		       /  \
		     14     10
(C)		    / \   /  \
		   8   7 9    3
         /  \ /
		2   4 1

=======================================================

QUICKSORT

PARTITION
Suppose we want to partition the array A=[2,8,7,1,3,5,6,4]

 |2|8|7|1|3|5|6|4|
i^              x^

j=0...6

j=0
A[0]=2 < 4=x
	i=-1+1=0
	A[0]exchange with A[0]

 |2|8|7|1|3|5|6|4|
  i^j^         x^

j=1
A[1]=8 > 4
nothig to do

j=2
A[2]=7 > 4
nothing to do

j=3
A[3]=1 < 4
	i=0+1=1
	A[1]=1 and A[3]=8
 |2|1|7|8|3|5|6|4|
    i^  j^

j=4
A[4]=3 < 4
	i=1+1=2
	A[2]=3 and A[4]=7
 |2|1|3|8|7|5|6|4|
      i^  j^

j=5
A[5]=5 > 4
nothing to do
j=6
A[6]=6 > 4
nothing to do

end of for-loop
A[3]=4 and A[7]=8
 |2|1|3|4|7|5|6|8|
   <=4  i^  >4   ^

So what we can see from this is that the i index marks the lower limit
of the numbers that are greater than the value x while the j marks the 
upper bound. After all that we return the i which is the pivot or marker.

Now after doing the partitioning we can now call Quicksort in each subarray
like this:
if(p < r) {
	q = Partition(a,p,r)
	Quicksort(a, p, q-1);
	Quicksort(a, q+1, r);
}
after this both arrays are gonna be sorted and as the value in the first call
to Partition acts as a pivot all the array is gonna be sorted.
 |1|2|3|4|5|6|7|8|
        ^
       pivot

======================================================================================
RANDOMIZED QUICKSORT
Just randomized the pivot selection to simulate an average case of a quicksort
that has a great performance.
======================================================================================
Hoare partition is another way to make the partition in a more efficient way.
The previous partition is known as Lomuto partitioning. In the Hoare partitioning
instead of set the index i and j at the begining we set this indexes at the extreme
i at the begining and j at the end. We move toward each other these indexes until
they detect a pair of elements, one greater or equal than the pivot, one lesser or
equal. Then these elements are swapped, below I show you the pseudocode:

Hoare_partition(A,p,r)
pivot = A[p]
i = p - 1
j = r + 1
while True
	repeat
		j = j - 1
	until A[j] <= x
	repeat 
		i = i + 1
	until A[i] >= x
	if i < j
		EXCHANGE A[i] and A[j]
	else return j
=========================================================================================
